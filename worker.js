// src/worker.ts
chrome.runtime.onInstalled.addListener(() => {
  chrome.storage.sync.set({
    fetchOnHover: false,
    requireCntrl: false,
    blacklist: {},
    ensCache: {},
    lastEnsReset: Date.now()
  });
});
function parseValue(usd) {
  if (!usd)
    return 0;
  return Number(usd.replace(/\$|,/g, ""));
}
function cutStr(str, startIdx, from, fromExpand, to, defaultValue, regex, format) {
  try {
    let idx = str.indexOf(from, startIdx);
    if (idx === -1)
      throw -1;
    idx += from.length;
    if (fromExpand) {
      const endIdx = str.indexOf(fromExpand, idx);
      if (endIdx === -1)
        throw -1;
      idx = endIdx + fromExpand.length;
    }
    const toIdx = str.indexOf(to, idx);
    const cut = str.substring(idx, toIdx);
    const cleaned = regex ? cut.replace(regex, "") : cut;
    const result = format ? format(cleaned) : cleaned;
    return [result, toIdx];
  } catch {
    return [defaultValue, startIdx];
  }
}
var ENS_MAP = {};
chrome.storage.sync.get("ensCache", (storage) => ENS_MAP = storage.ensCache);
chrome.runtime.onSuspend.addListener(() => chrome.storage.sync.set({ ensCache: ENS_MAP }));
async function resolveEnsName(id) {
  const cached = ENS_MAP[id];
  if (cached)
    return await Promise.resolve(cached);
  const loopup = new Promise(async (r) => {
    const res = await fetch("https://etherscan.io/enslookup-search?search=" + id);
    const ethscan = await res.text();
    const [address] = cutStr(ethscan, 100, `='txtEthereumAddress`, ">", "</span>", null);
    if (address) {
      ENS_MAP[address] = id;
      ENS_MAP[id] = address;
      r(address);
    } else {
      r(null);
    }
  });
  ENS_MAP[id] = loopup;
  return await loopup;
}
var CACHE = {};
async function fetchAddress(message, sendResponse) {
  let address;
  let ensName;
  let addressOrEns = message.id.toLowerCase();
  const cached = CACHE[addressOrEns];
  if (cached) {
    const response = await Promise.resolve(cached);
    sendResponse(response);
    return;
  }
  if (addressOrEns.startsWith("0x")) {
    address = addressOrEns;
    ensName = await Promise.resolve(ENS_MAP[address]);
  } else {
    const resolved = await resolveEnsName(addressOrEns);
    if (resolved) {
      address = resolved;
      ensName = addressOrEns;
    } else {
      sendResponse({
        type: "ADDRESS_RESPONSE",
        address,
        ens: addressOrEns,
        failed: true
      });
    }
  }
  try {
    const r = await fetch("https://etherscan.io/address/" + address);
    let ethscan = await r.text();
    let [tag] = cutStr(ethscan, 0, "og:title", `="`, "Address", "");
    if (tag)
      tag = tag.substring(0, tag.length - 3);
    ethscan = ethscan.substring(ethscan.indexOf("col-md-8") - 2);
    const [ether, ethIdx] = cutStr(ethscan, 0, "col-md-8", ">", "</div>", 0, /\sEther|<b>|<\/b>|,/g, parseValue);
    const [etherValue, ethVIdx] = cutStr(ethscan, ethIdx, "col-md-8", ">", "<span", 0, /\s|\$|,/g, parseValue);
    const [allTokensValue, atvIdx] = cutStr(ethscan, ethVIdx, "availableBalanceDropdown", ">", "<span", 0, />|\s|\$|,/g, parseValue);
    ethscan = ethscan.substring(atvIdx);
    let lastTokenIdx = ethscan.indexOf("list-custom-ERC20");
    let tokens = [];
    let moreTokens = lastTokenIdx >= 0;
    while (moreTokens) {
      const [img, imgIdx] = cutStr(ethscan, lastTokenIdx, "list-custom-ERC20", `<img src='`, `'`, null);
      if (img === null)
        break;
      const [amount, amtIdx] = cutStr(ethscan, imgIdx, `class='list-amount`, ">", " ", 0, void 0, parseValue);
      const [symbol, symIdx] = cutStr(ethscan, amtIdx, " ", null, "</span>", null);
      const [value, valIdx] = cutStr(ethscan, symIdx, "<span", ">", "</span>", 0, void 0, (s) => parseValue(s) || 0);
      tokens.push({ symbol, img, amount, value });
      lastTokenIdx = valIdx;
    }
    const tokenCount = tokens.length;
    tokens = tokens.sort((a, b) => a.value - b.value).slice(-3).reverse();
    tokens.forEach((t) => t.img = "https://etherscan.io" + t.img);
    const tokenValue = tokens.reduce((p, c) => p + c.value, 0);
    if (!ensName) {
      const [parsedEns] = cutStr(ethscan, Math.max(lastTokenIdx, 1), `id='ensName'`, "> ", "</a>", null, /\s/g);
      if (parsedEns)
        ensName = parsedEns;
    }
    const response = {
      type: "ADDRESS_RESPONSE",
      address,
      ens: ensName,
      tag,
      ether,
      etherValue,
      tokens,
      tokenCount,
      tokensValue: allTokensValue,
      remainingTokensValue: allTokensValue > tokenValue ? allTokensValue - tokenValue : void 0
    };
    CACHE[address] = response;
    CACHE[ensName] = response;
    sendResponse(response);
  } catch (ex) {
    console.error(ex);
    sendResponse({
      type: "ADDRESS_RESPONSE",
      address,
      ens: ensName,
      failed: true
    });
  }
}
chrome.runtime.onMessage.addListener((message, _, sendResponse) => {
  switch (message.type) {
    case "ENS_RESOLVE":
      resolveEnsName(message.id).then((address) => {
        if (address) {
          sendResponse({ type: "ENS_RESPONSE", address });
        } else {
          sendResponse({ type: "ENS_RESPONSE", failed: true });
        }
      });
      return true;
    case "ADDRESS_REQUEST":
      fetchAddress(message, sendResponse);
      return true;
    case "RESET_CACHE":
      ENS_MAP = {};
      CACHE = {};
      return false;
  }
  return false;
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL3dvcmtlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiY2hyb21lLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoKCkgPT4ge1xyXG4gIGNocm9tZS5zdG9yYWdlLnN5bmMuc2V0KHtcclxuICAgIGZldGNoT25Ib3ZlcjogZmFsc2UsXHJcbiAgICByZXF1aXJlQ250cmw6IGZhbHNlLFxyXG4gICAgYmxhY2tsaXN0OiB7fSxcclxuICAgIGVuc0NhY2hlOiB7fSxcclxuICAgIGxhc3RFbnNSZXNldDogRGF0ZS5ub3coKVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlVmFsdWUodXNkOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKSB7XHJcbiAgaWYgKCF1c2QpIHJldHVybiAwO1xyXG4gIHJldHVybiBOdW1iZXIodXNkLnJlcGxhY2UoL1xcJHwsL2csICcnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1dFN0cjxUID0gc3RyaW5nPihzdHI6IHN0cmluZywgc3RhcnRJZHg6IG51bWJlciwgZnJvbTogc3RyaW5nLCBmcm9tRXhwYW5kOiBzdHJpbmcgfCBudWxsLCB0bzogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IFQsIHJlZ2V4PzogUmVnRXhwLCBmb3JtYXQ/OiAoczogc3RyaW5nKSA9PiBUKSB7XHJcbiAgdHJ5IHtcclxuICAgIGxldCBpZHggPSBzdHIuaW5kZXhPZihmcm9tLCBzdGFydElkeCk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkgdGhyb3cgLTE7XHJcbiAgICBpZHggKz0gZnJvbS5sZW5ndGg7XHJcbiAgICBpZiAoZnJvbUV4cGFuZCkge1xyXG4gICAgICBjb25zdCBlbmRJZHggPSBzdHIuaW5kZXhPZihmcm9tRXhwYW5kLCBpZHgpO1xyXG4gICAgICBpZiAoZW5kSWR4ID09PSAtMSkgdGhyb3cgLTE7XHJcbiAgICAgIGlkeCA9IGVuZElkeCArIGZyb21FeHBhbmQubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdG9JZHggPSBzdHIuaW5kZXhPZih0bywgaWR4KTtcclxuICAgIGNvbnN0IGN1dCA9IHN0ci5zdWJzdHJpbmcoaWR4LCB0b0lkeCk7XHJcbiAgICBjb25zdCBjbGVhbmVkID0gcmVnZXggPyBjdXQucmVwbGFjZShyZWdleCwgJycpIDogY3V0O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0ID8gZm9ybWF0KGNsZWFuZWQpIDogY2xlYW5lZDtcclxuICAgIHJldHVybiBbcmVzdWx0IGFzIFQsIHRvSWR4XSBhcyBjb25zdDtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBbZGVmYXVsdFZhbHVlLCBzdGFydElkeF0gYXMgY29uc3Q7XHJcbiAgfVxyXG59XHJcblxyXG5sZXQgRU5TX01BUDogeyBbYWRkcmVzc09yRW5zOiBzdHJpbmddOiBzdHJpbmcgfCBQcm9taXNlPHN0cmluZyB8IG51bGw+IH0gPSB7fTtcclxuY2hyb21lLnN0b3JhZ2Uuc3luYy5nZXQoJ2Vuc0NhY2hlJywgc3RvcmFnZSA9PiBFTlNfTUFQID0gc3RvcmFnZS5lbnNDYWNoZSk7XHJcbmNocm9tZS5ydW50aW1lLm9uU3VzcGVuZC5hZGRMaXN0ZW5lcigoKSA9PiBjaHJvbWUuc3RvcmFnZS5zeW5jLnNldCh7IGVuc0NhY2hlOiBFTlNfTUFQIH0pKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVFbnNOYW1lKGlkOiBzdHJpbmcpIHtcclxuICBjb25zdCBjYWNoZWQgPSBFTlNfTUFQW2lkXTtcclxuICBpZiAoY2FjaGVkKSByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgY29uc3QgbG9vcHVwID0gbmV3IFByb21pc2U8c3RyaW5nIHwgbnVsbD4oYXN5bmMgciA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9ldGhlcnNjYW4uaW8vZW5zbG9va3VwLXNlYXJjaD9zZWFyY2g9JyArIGlkKTtcclxuICAgIGNvbnN0IGV0aHNjYW4gPSBhd2FpdCByZXMudGV4dCgpO1xyXG4gICAgY29uc3QgW2FkZHJlc3NdID0gY3V0U3RyPHN0cmluZyB8IG51bGw+KGV0aHNjYW4sIDEwMCwgYD0ndHh0RXRoZXJldW1BZGRyZXNzYCwgJz4nLCAnPC9zcGFuPicsIG51bGwpO1xyXG4gICAgaWYgKGFkZHJlc3MpIHtcclxuICAgICAgRU5TX01BUFthZGRyZXNzXSA9IGlkO1xyXG4gICAgICBFTlNfTUFQW2lkXSA9IGFkZHJlc3M7XHJcbiAgICAgIHIoYWRkcmVzcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByKG51bGwpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIEVOU19NQVBbaWRdID0gbG9vcHVwO1xyXG4gIHJldHVybiBhd2FpdCBsb29wdXA7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmV2ZXJzZUVuc0xvb2t1cChhZGRyZXNzOiBzdHJpbmcpIHtcclxuICBjb25zdCBjYWNoZWQgPSBFTlNfTUFQW2FkZHJlc3NdO1xyXG4gIGlmIChjYWNoZWQpIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2FjaGVkKTtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9ldGhlcnNjYW4uaW8vZW5zbG9va3VwLXNlYXJjaD9zZWFyY2g9JyArIGFkZHJlc3MpO1xyXG4gIGNvbnN0IGV0aHNjYW4gPSBhd2FpdCByZXMudGV4dCgpO1xyXG4gIGNvbnN0IFtlbnNdID0gY3V0U3RyPHN0cmluZyB8IG51bGw+KGV0aHNjYW4sIDEwMCwgYGFsdD0nRVRIJ2AsICc+JywgJzwvc3Bhbj4nLCBudWxsKTtcclxuICBpZiAoZW5zKSB7XHJcbiAgICBFTlNfTUFQW2Vuc10gPSBhZGRyZXNzO1xyXG4gICAgRU5TX01BUFthZGRyZXNzXSA9IGVucztcclxuICAgIHJldHVybiBlbnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxubGV0IENBQ0hFOiB7IFthZGRyZXNzT3JFbnM6IHN0cmluZ106IHVua25vd24gfSA9IHt9O1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFkZHJlc3MobWVzc2FnZTogYW55LCBzZW5kUmVzcG9uc2U6IChyZXNwb25zZT86IGFueSkgPT4gdm9pZCkge1xyXG4gIGxldCBhZGRyZXNzOiBzdHJpbmcgfCBudWxsO1xyXG4gIGxldCBlbnNOYW1lOiBzdHJpbmcgfCBudWxsO1xyXG4gIGxldCBhZGRyZXNzT3JFbnMgPSBtZXNzYWdlLmlkLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIGNvbnN0IGNhY2hlZCA9IENBQ0hFW2FkZHJlc3NPckVuc107XHJcbiAgaWYgKGNhY2hlZCkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2FjaGVkKTtcclxuICAgIHNlbmRSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoYWRkcmVzc09yRW5zLnN0YXJ0c1dpdGgoJzB4JykpIHtcclxuICAgIGFkZHJlc3MgPSBhZGRyZXNzT3JFbnM7XHJcbiAgICBlbnNOYW1lID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKEVOU19NQVBbYWRkcmVzcyFdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCByZXNvbHZlRW5zTmFtZShhZGRyZXNzT3JFbnMpO1xyXG4gICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgIGFkZHJlc3MgPSByZXNvbHZlZDtcclxuICAgICAgZW5zTmFtZSA9IGFkZHJlc3NPckVucztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNlbmRSZXNwb25zZSh7XHJcbiAgICAgICAgdHlwZTogJ0FERFJFU1NfUkVTUE9OU0UnLFxyXG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MhLFxyXG4gICAgICAgIGVuczogYWRkcmVzc09yRW5zLFxyXG4gICAgICAgIGZhaWxlZDogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZXRoZXJzY2FuLmlvL2FkZHJlc3MvJyArIGFkZHJlc3MhKTtcclxuICAgIGxldCBldGhzY2FuID0gKGF3YWl0IHIudGV4dCgpKTtcclxuXHJcbiAgICBsZXQgW3RhZ10gPSBjdXRTdHIoZXRoc2NhbiwgMCwgJ29nOnRpdGxlJywgYD1cImAsICdBZGRyZXNzJywgJycpO1xyXG4gICAgaWYgKHRhZykgdGFnID0gdGFnLnN1YnN0cmluZygwLCB0YWcubGVuZ3RoIC0gMyk7XHJcblxyXG4gICAgLy8gY3V0IHRoZSBkb20gc3RyaW5nIHRvIHdoYXQgd2UgbmVlZFxyXG4gICAgZXRoc2NhbiA9IGV0aHNjYW4uc3Vic3RyaW5nKGV0aHNjYW4uaW5kZXhPZignY29sLW1kLTgnKSAtIDIpO1xyXG5cclxuICAgIGNvbnN0IFtldGhlciwgZXRoSWR4XSA9IGN1dFN0cihldGhzY2FuLCAwLCAnY29sLW1kLTgnLCAnPicsICc8L2Rpdj4nLCAwLCAvXFxzRXRoZXJ8PGI+fDxcXC9iPnwsL2csIHBhcnNlVmFsdWUpO1xyXG4gICAgY29uc3QgW2V0aGVyVmFsdWUsIGV0aFZJZHhdID0gY3V0U3RyKGV0aHNjYW4sIGV0aElkeCwgJ2NvbC1tZC04JywgJz4nLCAnPHNwYW4nLCAwLCAvXFxzfFxcJHwsL2csIHBhcnNlVmFsdWUpO1xyXG5cclxuICAgIGNvbnN0IFthbGxUb2tlbnNWYWx1ZSwgYXR2SWR4XSA9IGN1dFN0cihldGhzY2FuLCBldGhWSWR4LCAnYXZhaWxhYmxlQmFsYW5jZURyb3Bkb3duJywgJz4nLCAnPHNwYW4nLCAwLCAvPnxcXHN8XFwkfCwvZywgcGFyc2VWYWx1ZSk7XHJcblxyXG4gICAgLy8gY3V0IGV2ZW4gbW9yZSBmb3IgdG9rZW4gcGFyc2luZ1xyXG4gICAgZXRoc2NhbiA9IGV0aHNjYW4uc3Vic3RyaW5nKGF0dklkeCk7XHJcblxyXG4gICAgbGV0IGxhc3RUb2tlbklkeCA9IGV0aHNjYW4uaW5kZXhPZignbGlzdC1jdXN0b20tRVJDMjAnKTtcclxuICAgIGxldCB0b2tlbnM6IHsgc3ltYm9sLCBpbWcsIGFtb3VudCwgdmFsdWUgfVtdID0gW107XHJcbiAgICBsZXQgbW9yZVRva2VucyA9IGxhc3RUb2tlbklkeCA+PSAwO1xyXG4gICAgd2hpbGUgKG1vcmVUb2tlbnMpIHtcclxuICAgICAgY29uc3QgW2ltZywgaW1nSWR4XSA9IGN1dFN0cjxzdHJpbmcgfCBudWxsPihldGhzY2FuLCBsYXN0VG9rZW5JZHgsICdsaXN0LWN1c3RvbS1FUkMyMCcsIGA8aW1nIHNyYz0nYCwgYCdgLCBudWxsKTtcclxuICAgICAgaWYgKGltZyA9PT0gbnVsbCkgYnJlYWs7XHJcbiAgICAgIGNvbnN0IFthbW91bnQsIGFtdElkeF0gPSBjdXRTdHIoZXRoc2NhbiwgaW1nSWR4LCBgY2xhc3M9J2xpc3QtYW1vdW50YCwgJz4nLCAnICcsIDAsIHVuZGVmaW5lZCwgcGFyc2VWYWx1ZSk7XHJcbiAgICAgIGNvbnN0IFtzeW1ib2wsIHN5bUlkeF0gPSBjdXRTdHIoZXRoc2NhbiwgYW10SWR4LCAnICcsIG51bGwsICc8L3NwYW4+JywgbnVsbCk7XHJcbiAgICAgIGNvbnN0IFt2YWx1ZSwgdmFsSWR4XSA9IGN1dFN0cihldGhzY2FuLCBzeW1JZHgsICc8c3BhbicsICc+JywgJzwvc3Bhbj4nLCAwLCB1bmRlZmluZWQsIHMgPT4gcGFyc2VWYWx1ZShzKSB8fCAwKTtcclxuICAgICAgdG9rZW5zLnB1c2goeyBzeW1ib2wsIGltZywgYW1vdW50LCB2YWx1ZSB9KTtcclxuICAgICAgbGFzdFRva2VuSWR4ID0gdmFsSWR4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XHJcbiAgICB0b2tlbnMgPSB0b2tlbnMuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpLnNsaWNlKC0zKS5yZXZlcnNlKCk7XHJcbiAgICB0b2tlbnMuZm9yRWFjaCh0ID0+IHQuaW1nID0gJ2h0dHBzOi8vZXRoZXJzY2FuLmlvJyArIHQuaW1nKTtcclxuICAgIGNvbnN0IHRva2VuVmFsdWUgPSB0b2tlbnMucmVkdWNlKChwLCBjKSA9PiBwICsgYy52YWx1ZSwgMCk7XHJcblxyXG4gICAgaWYgKCFlbnNOYW1lISkge1xyXG4gICAgICBjb25zdCBbcGFyc2VkRW5zXSA9IGN1dFN0cihldGhzY2FuLCBNYXRoLm1heChsYXN0VG9rZW5JZHgsIDEpLCBgaWQ9J2Vuc05hbWUnYCwgJz4gJywgJzwvYT4nLCBudWxsLCAvXFxzL2cpO1xyXG4gICAgICBpZiAocGFyc2VkRW5zKSBlbnNOYW1lID0gcGFyc2VkRW5zO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0ge1xyXG4gICAgICB0eXBlOiAnQUREUkVTU19SRVNQT05TRScsXHJcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MhLFxyXG4gICAgICBlbnM6IGVuc05hbWUhLFxyXG4gICAgICB0YWcsXHJcbiAgICAgIGV0aGVyLFxyXG4gICAgICBldGhlclZhbHVlLFxyXG4gICAgICB0b2tlbnMsXHJcbiAgICAgIHRva2VuQ291bnQsXHJcbiAgICAgIHRva2Vuc1ZhbHVlOiBhbGxUb2tlbnNWYWx1ZSxcclxuICAgICAgcmVtYWluaW5nVG9rZW5zVmFsdWU6IGFsbFRva2Vuc1ZhbHVlID4gdG9rZW5WYWx1ZSA/IChhbGxUb2tlbnNWYWx1ZSAtIHRva2VuVmFsdWUpIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgQ0FDSEVbYWRkcmVzcyFdID0gcmVzcG9uc2U7XHJcbiAgICBDQUNIRVtlbnNOYW1lIV0gPSByZXNwb25zZTtcclxuICAgIHNlbmRSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgfSBjYXRjaCAoZXgpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xyXG4gICAgc2VuZFJlc3BvbnNlKHtcclxuICAgICAgdHlwZTogJ0FERFJFU1NfUkVTUE9OU0UnLFxyXG4gICAgICBhZGRyZXNzOiBhZGRyZXNzISxcclxuICAgICAgZW5zOiBlbnNOYW1lISxcclxuICAgICAgZmFpbGVkOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigobWVzc2FnZSwgXywgc2VuZFJlc3BvbnNlKSA9PiB7XHJcbiAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcclxuICAgIGNhc2UgJ0VOU19SRVNPTFZFJzpcclxuICAgICAgcmVzb2x2ZUVuc05hbWUobWVzc2FnZS5pZCkudGhlbihhZGRyZXNzID0+IHtcclxuICAgICAgICBpZiAoYWRkcmVzcykge1xyXG4gICAgICAgICAgc2VuZFJlc3BvbnNlKHsgdHlwZTogJ0VOU19SRVNQT05TRScsIGFkZHJlc3MgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHR5cGU6ICdFTlNfUkVTUE9OU0UnLCBmYWlsZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlICdBRERSRVNTX1JFUVVFU1QnOlxyXG4gICAgICBmZXRjaEFkZHJlc3MobWVzc2FnZSwgc2VuZFJlc3BvbnNlKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlICdSRVNFVF9DQUNIRSc6XHJcbiAgICAgIEVOU19NQVAgPSB7fTtcclxuICAgICAgQ0FDSEUgPSB7fTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2VcclxufSk7XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQSxPQUFPLFFBQVEsWUFBWSxZQUFZLE1BQU07QUFDM0MsU0FBTyxRQUFRLEtBQUssSUFBSTtBQUFBLElBQ3RCLGNBQWM7QUFBQSxJQUNkLGNBQWM7QUFBQSxJQUNkLFdBQVcsQ0FBQztBQUFBLElBQ1osVUFBVSxDQUFDO0FBQUEsSUFDWCxjQUFjLEtBQUssSUFBSTtBQUFBLEVBQ3pCLENBQUM7QUFDSCxDQUFDO0FBRUQsb0JBQW9CLEtBQWdDO0FBQ2xELE1BQUksQ0FBQztBQUFLLFdBQU87QUFDakIsU0FBTyxP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
